// The code was inspired by a video I saw of someone who had never conducted an
// orchestra trying to conduct one to illustrate that being an orchestra
// conductor is not a simple feat. I resonated with the idea of linking sound to
// movement, and discovered that it is actually a lot more complicated of a
// process than it may seem. Initially I struggled with my concept because I
// wanted to create something that had more of an emotional tie but as I dove
// away from the idea of long form generative art in the pursuit of
// interactivity with audio, I became more drawn to it's ability. I was inspired
// by Kala's "Ambient Raga" https://www.fxhash.xyz/generative/10379 , which tied
// sound to a landscape and movement. I really wanted to include human based
// movement in my project and so I evolved from creating something adjacent to a
// moving sound landscape to creating a soundscape that was generated by the
// viewer through movement that triggered sound. I referenced this ml5 resource
// page to understand the code + it's trigger points (see the diagram here:
// https://docs.ml5js.org/#/reference/handpose?id=methods) and had the visual
// component of my work inspired by this github sketch:
// https://github.com/colorful-coding/coding-projects/blob/main/Coding%20Project%20%239/script.js.
// Additionally, I used ChatGPT to explain some of the logic for the code that
// was tricky (the math to calculate circle related graphics and overall
// optimizing the code- shorthand formats, image objects, implementing the math
// into code for the music
// (https://en.wikipedia.org/wiki/Piano_key_frequencies)) 

// The parameters that define the generative system are the color values of the
// drawn particles, the angles at which they are moving (higher= more jerky,
// lower= smoother), and the noise seed for the Perlin noise that the particles'
// motions are based off of.

let handPose;

let starField;    //  background field of stars
let cosmicDance;  //  collection of cosmic particles
let cosmicCanvas; //  separate canvas for cosmic

let video;
let hands = [];   //  hands detected
let handSprite;   //  glow for hand

let muted = false; //  playing soundscape y/n

let blackKeys = [2, 4, 7, 9, 11];

// parameters 4 cosmic flow 
let r1, r2, g1, g2, b1, b2;
let angleScale;

// parameter 4 background stars tumble speed
let fieldTumbleRate = -1 / 100; // remember negative = anticlockwise

let handState = "open"; // open --> closing --> closed --> open
let closingStartMS = 0; // when did the state change last time

let playButton;
let playing = false;
let previewImg = null;

// state must stay in 'closing' for this many millis to move state to closed
const closingDelayMS = 1000;

function preload() {
  handPose = ml5.handPose({ maxHands: 2, flipped: true });
  previewImg = loadImage("preview.jpg");
}

function setup() {
  angleMode(DEGREES);
  noiseDetail(1);

  createCanvas(windowWidth, windowHeight);
  //so that we have trails
  cosmicCanvas = createGraphics(width, height);

  let radius = min(width, height) / 16;
  playButton = new PlayButton(width / 2, height / 2, radius);
}

function startPlaying() {
  video = createCapture(VIDEO);
  video.hide();
  video.size(width, height);

  handPose.detectStart(video, gotHands);

  
  handSprite = createHandSprite();

  reset();

  playing = true;
}

// reset sketch
function reset() {
  angleScale = random(0.003, 0.015);

  // reset starfield
  let starDensity = 75 * 75; // one star every 75x75 pixels roughly
  let numStars = (width * height) / starDensity;
  starField = new StarField(
    numStars,
    -width / 2,
    -height / 2,
    width / 2,
    height / 2
  );

  // reset cosmic dance
  if (cosmicDance) {
    cosmicDance.mute();
  }
  cosmicDance = new CosmicDance();

  // reset cosmicCanvas
  cosmicCanvas.clear();
}

function draw() {
  background("#06003018");
  if (!playing) {
    push();
    imageMode(CENTER);
    image(previewImg, width / 2, height / 2, width, height);
    pop();
    return;
  }

  // draw background starfield
  push();
  translate(width / 2, height / 2);
  rotate(frameCount * fieldTumbleRate);
  starField.draw();
  pop();

  // draw cosmic particles
  cosmicDance.draw();
  image(cosmicCanvas, 0, 0, width, height);

  // draw hand markers
  drawHands();
}

// calls detectGesture
function onHandClosed(g) {
  print("Hand Closed");
}

// splatter on open
function onHandOpened(g) {
  let numParticles = int(random(12, 42));
  cosmicDance.splatter(numParticles, g.cx, g.cy, g.dPalm);
}

class PlayButton {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;

    this.btn = createButton('');
    this.btn.class("play-button");
    this.btn.position(width / 2 - this.radius, height / 2 - this.radius);
    this.btn.mousePressed(() => {
      this.btn.hide();
      startPlaying();
    });
  }
  position(x, y) {
    this.x = x;
    this.y = y;
    this.btn.position(x - this.radius, y - this.radius);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  if (video) video.size(width, height);
  reset();
  playButton.position(width / 2, height / 2);
}

//  keypressed
function keyPressed() {
  if (key === " ") {
    // reset the drawing
    reset();
  } else if (key === "m") {
    // toggle the muted state
    if (muted) {
      cosmicDance.unmute();
      muted = false;
    } else {
      cosmicDance.mute();
      muted = true;
    }
  }
}

function gotHands(results) {
  //summary of hand data
  hands = results;
}

function drawHands() {
  for (let hand of hands) {

    if (hand.confidence < 0.25) continue;
    let g = detectGesture(hand);

    imageMode(CENTER);
    image(handSprite, g.cx, g.cy, g.dFingers, g.dFingers);
    imageMode(CORNER);

    if (handState === "closed") {
      //ring      
      push();
      noFill();
      strokeWeight(2);
      stroke("#ffffff60");
      circle(g.cx, g.cy, g.dPalm / 2);
      pop();
    } else if (handState === "closing") {
      //timer circle 
      push();
      noFill();
      strokeWeight(2);
      stroke("#FFFFFF40");

      //map %circle drawn to millis
      let theta = map(millis() - closingStartMS, 0, closingDelayMS, 0, 360);
      arc(g.cx, g.cy, g.dPalm / 2, g.dPalm / 2, 0, theta, OPEN);
      pop();
    }
  }
}

// detects gesture + return
function detectGesture(hand) {
  // calculate the center of the hand 
  let cx = 0;
  let cy = 0;


  let palmPoints = [0, 1, 2, 5, 9, 13, 17];

  for (let i of palmPoints) {
    let pt = hand.keypoints[i];
    cx += pt.x;
    cy += pt.y;
  }

  // center is the average
  cx /= palmPoints.length;
  cy /= palmPoints.length;

  // average distance to 1st knuckle (palm)
  let dPalm = 0;
  for (let i of palmPoints) {
    let pt = hand.keypoints[i];
    dPalm += dist(cx, cy, pt.x, pt.y);
  }
  dPalm = dPalm / palmPoints.length;
  // avg tip - center length
  let dFingers = 0;
  let fingerTips = [4, 8, 12, 16, 20];
  for (let i of fingerTips) {
    let pt = hand.keypoints[i];
    dFingers += dist(cx, cy, pt.x, pt.y);
  }
  dFingers = dFingers / fingerTips.length;

  let result = {};
  result.cx = cx;
  result.cy = cy;
  result.dPalm = dPalm;
  result.dFingers = dFingers;

  // palm bigger than fingers?
  if (dPalm > dFingers) {
    //closed
    if (handState === "open") {
      handState = "closing";
      closingStartMS = millis();
    } else if (handState === "closing") {
      // closing, check if fully closed
      if (millis() - closingStartMS >= closingDelayMS) {
        handState = "closed";
        closingStartMS = 0;

        onHandClosed(result);
      }
    } else {
      //nada mas
    }
  } else {
    // fingers bigger than palm - open
    if (handState === "closed") {
      handState = "open";
      onHandOpened(result);
    } else if (handState === "closing") {
      //not
      handState = "open";
      closingStartMS = 0;
    } else {
      // nada mas
    }
  }
  return result;
}

// stars in the background
class StarField {
  //  two opposite corners rect x1, y1 and x2, y2
  constructor(numStars, x1, y1, x2, y2) {
    this.stars = [];
    for (let i = 0; i < numStars; i++) {
      let star = {};
      star.x = random(x1, x2);
      star.y = random(y1, y2);
      star.fill = color("white");
      star.radius = random(1, 5);
      this.stars.push(star);
    }
  }

  draw() {
    ellipseMode(CENTER);
    for (let star of this.stars) {
      noStroke();
      fill(star.fill);
      let r = star.radius * random(0.8, 1.2); // twinkling
      ellipse(star.x, star.y, r, r / 2);
      ellipse(star.x, star.y, r / 2, r);
    }
  }
}


// key number,  A4 = 49
function pianoKey(octave, key) {
  return octave * 12 - 9 + key;
}

//frequency of the nth piano key, A4=440Hz
function noteHz(n) {
  return pow(2, (n - 49) / 12) * 440;
}

// single charmed particle *freq at birth
class CharmedParticle {
  constructor(x, y, size, hz, amp) {
    this.radius = size / 2;

    this.pos = createVector(x, y); // *shorthand pos.x and pox.y
    this.hz = hz;
    this.amp = amp;


    // save current r g b globals for this particle
    this.r1 = r1;
    this.g1 = g1;
    this.b1 = b1;
    this.r2 = r2;
    this.g2 = g2;
    this.b2 = b2;

    if (this.hz > 30) {
      this.osc = new p5.Oscillator(hz, "sine");
      this.osc.amp(amp);
    }
  }

  draw() {

    let r = map(this.pos.x, 0, width, this.r1, this.r2);
    let g = map(this.pos.y, 0, height, this.g1, this.g2);
    let b = map(this.pos.x, 0, width, this.b1, this.b2);

    // ellipse formula: (x-cx)^2/rx^2 + (y-cy)^2/ry^2 <= 1
    // cx, cy is width/2 and height/2 and rx ry are width/2 and height/2
    let dx = (2.0 * this.pos.x) / width - 1;
    let dy = (2.0 * this.pos.y) / height - 1;
    let norm = dist(0, 0, dx, dy);
    let a = map(norm, 0, 1, 255, 0, true);


    var fuzz = noise(this.pos.x * angleScale, this.pos.y * angleScale);
    var theta = map(fuzz, 0, 1, 0, 720);
    this.pos.add(createVector(cos(theta), sin(theta)));
    cosmicCanvas.noStroke();
    cosmicCanvas.fill(r, g, b, a);
    cosmicCanvas.ellipse(this.pos.x, this.pos.y, max(1, this.radius));
  }

  mute() {
    if (this.osc) {
      this.osc.stop();
    }
  }

  unmute() {
    if (this.osc) {
      this.osc.start();
    }
  }
}

// all the cosmic particles 
class CosmicDance {
  constructor() {
    this.particles = [];
  }


  splatter(count, cx, cy, radius) {


    // parameters 4 color
    r1 = random(100);
    r2 = random(100);
    g1 = random(50);
    g2 = random(50);
    b1 = random(255);
    b2 = random(255);

    // noiseSeed: lines smooth or over each other
    noiseSeed(random(10));

    for (let i = 0; i < count; i++) {
      let r = random(radius);
      let theta = random(360);
      let freq = noteHz(pianoKey(int(random(3, 6)), random(blackKeys)));
      let amp = random(1 / 64, 1 / 2);

      let p = new CharmedParticle(
        cx + r * cos(theta),
        cy + r * sin(theta),
        random(2, 5),
        freq,
        amp
      );
      this.particles.push(p);
      if (!muted) {
        p.unmute();
      }
    }
  }

  draw() {
    for (let p of this.particles) {
      p.draw();
    }
  }

  mute() {
    for (let p of this.particles) {
      p.mute();
    }
  }

  unmute() {
    // note: this unmutes all particles
    for (let p of this.particles) {
      p.unmute();
    }
  }
}

// sprite time
function createHandSprite() {
  const R = 256;
  let g = createGraphics(2 * R, 2 * R);
  ellipseMode(CENTER);
  rectMode(CORNER);

  g.noStroke();

  for (let x = 0; x < 2 * R; x++) {
    for (let y = 0; y < 2 * R; y++) {
      let d = dist(x, y, R, R);

      let sigma = 0.3;
      let a = 80 * exp(-(d / R) * (d / R) / (2 * sigma * sigma)) / (sigma * sqrt(2 * PI));
      if (d <= R) {
        g.fill(0, 90, 36, a);
        g.rect(x, y, 1, 1);
      }
    }
  }


  return g;
}
